# Nx.Image Demonstration

```elixir
Mix.install([
  {:nx, "~> 0.4.0"},
  {:kino, git: "https://github.com/livebook-dev/kino"},
  {:nx_image, git: "https://github.com/elixir-nx/nx_image.git"}
])
```

## Upload your test image

Using a Livebook release greater than 0.7.2, we can add the new Kino.Input.image/1 to upload an image to our notebook.

```elixir
img = Kino.Input.image("Uploaded Image")
```

We can use Input.read/ to retrieve the information about our image.

```elixir
%{data: content, format: _, height: height, width: width} = Kino.Input.read(img)
```

NxImage requires that the images be tensors in either HWC or CHW order,
  with an arbitrary number of leading batch axes

```elixir
image_tensor =
  Nx.from_binary(content, :u8)
  |> Nx.reshape({height, width, 3})
```

Now that we have a tensor in the form of {Height, Width, Channels} we can load into NxImage.

## NxImage Center Crop

The first capability we'll look at is the center crop.

```elixir
centor_crop_tensor = NxImage.center_crop(image_tensor, {300, 300})
```

We've transformed the image from its original size to 300 x 300 by taking the pixels 150 above and below the image center.  Similarly we have the 150 pixels to the left and right of the center point.

## Visualizing the Center Cropped Image

Numbers are great, but most of us are visual focused.  Let's see what center crop looks like on our uploaded image.

```elixir
center_crop_image = Kino.Image.new(centor_crop_tensor)

label = Kino.Markdown.new("** Center of image **")

center_image_display = [
  Kino.Layout.grid([center_crop_image, label], boxed: true)
]

Kino.Layout.grid(center_image_display)
```

## NxImage Resize

We'll resize the image.  Whether this resized image is shrunk or enlarged is dependent upon the original image size.  Resizing to a standard size can be useful when training visual models on a diverse set of source images.

```elixir
resized_tensor = NxImage.resize(image_tensor, {768, 768}, method: :nearest)
```

## Visualizing the Resized Image

Let's display the original image and the resized image.  Hmmm.  We really can't visually tell whether it has been resized in the notebook.

```elixir
resized_image = Kino.Image.new(resized_tensor)
orig_image = Kino.Image.new(image_tensor)

orig_label = Kino.Markdown.new("Original image")
resized_label = Kino.Markdown.new("** Resized image **")

resized_image_display = [
  Kino.Layout.grid([orig_image, orig_label], boxed: true),
  Kino.Layout.grid([resized_image, resized_label], boxed: true)
]

Kino.Layout.grid(resized_image_display)
```

Let's double check the shape of both images.  We can see that the resized image has a different shape from the original image shape.

```elixir
{image_tensor.shape, resized_tensor.shape}
```

## Further Exploration

Exercise: How do the options, bilinear bicubic lanczos3 lanczos5, affect your resized image?

<!-- livebook:{"break_markdown":true} -->

Also, we'll leave exploring the NxImage.normalize as an additional exercise.  Normalization is a useful for transfer learning situations where an original model is further trained on a set of images from your custom domain.  The original images had a particular mean and standard deviation.  When transfer learning from the base model, your source images are normalized in the same manner as the distribution of the original set of images.
